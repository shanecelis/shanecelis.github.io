+++
title = "Object Oriented Programming in Rustâ€”Yuck and Yet..."
date = "2023-05-07"
+++

# Introduction

I remember a coworker, gosh, maybe two decades ago, telling me you can write
object oriented code in any language even C. We were writing Java at the time
(see, a long time ago), and I was confused because obviously the C language does
not natively support object oriented programming but [he was
right](https://staff.washington.edu/gmobus/Academics/TCES202/Moodle/OO-ProgrammingInC.html).
Many people have written object oriented code in C. For instance
[GTK](https://www.gtk.org) uses the [GObject
library](https://en.wikipedia.org/wiki/GObject). So object oriented programming
can be done in C but the language does not explicitly facilitate it. Rust is
another language that does not natively support conventional object oriented
programming, but they can't stop us from doing object oriented programming if
that's what we're determined to do.

# Object Oriented Programming

![Object oriented mind graph showing it connect polymorphism, abstraction,
 encapsulation, inheritance, classes, and objects](oo.png)

What is object oriented programming? Gosh, it's been with us so long it's hard
to think of what it actually means.

* A class defines some data and provides public methods.

* An object is an instance of a class, of which there can be many.

* Encapsulation: The data a class defines may be private and its public methods
constitute its programmatic interface.

* Inheritance: One can extend a class adding new data and modifying its methods.

* Abstraction: A caller---that can interact with a class---can also interact
with any of its subclasses. Likewise a caller---that can interact with an
interface---can interact with any of its implementers.

## Polymorphism

What is polymorphism? Polymorphism is the ability to access objects of different
types through the same programmatic interface. There is subclass polymorphism: a
child class can be substituted anywhere that accepts its parent. There is interface
polymorphism: a class that implements an interface can be substituted anywhere
that accepts that interface.

Furthermore there are two variants of polymorphism: static and dynamic. With
dynamic polymorphism a caller does not need to know the class yet it can still
interact with its interface properly. Dynamic polymorphism is traditionally
implemented with a virtual method table that each class and subclass maintains.
This introduces a small overhead since the method is not known at compile time:
there's an lookup for a virtual method call. This is also called dynamic
dispatch.

Then there is static polymorphism, where code can be written to work some
interface but the compiler knows what class is given and omits the dynamic
dispatch and calls the class's method directly.

# A Model Animal

Rust doesn't have interfaces, but it does have traits. But let's try to use a
trait as though it were an interface. We'll try and create the canonical object
oriented animal example.

```{.rust .cb-nb session=a}
trait Animal {
  fn cry();
  fn sleep();
  fn roam();
}
```

It crys, sleeps, and roams. What more could you ask for?

## A Cat

Let's make a `Cat` "class" to implement it. Rust calls it a struct.

```{.rust .cb-nb session=a}
struct Cat {}
```

```{.rust .cb-nb session=a}

impl Animal for Cat {
  fn cry() {
    println!("meow");
  }
  fn sleep() {
    println!("Zzzz");
  }
  fn roam() {
    println!("patter patter pounce");
  }
}
```

### Run it

[{{ resize_image(path="crying-cat-meme.png", height=250, op="fit_height", alt="Crying cat meme in pixel art form by PixelPandaArts") }}](https://www.deviantart.com/pixelpandaarts/art/Crying-Cat-Meme-900571649)

We can exercise it like so.

```{.rust .cb-nb session=a}
Cat::cry();
```

However, this `cry()` is akin to a static method by Java or
C# terminology. There is no instance or object it is called on. Static methods
aren't really capable of any dynamic polymorphism.

### Static Polymorphism 

However, rust can do static polymorphism. Say we had another "class" called
`Bird`.

```{.rust .cb-nb session=a}
struct Bird {}

impl Animal for Bird {
  fn cry() {
    println!("chirp");
  }
  fn sleep() {
    println!("Zzzz");
  }
  fn roam() {
    println!("flit flit flurp");
  }
}
```

We can of couse make calls on the class like so.

```{.rust .cb-nb session=a}
Bird::roam();
```

But we can also use rust's generics to write code that will handle any `Animal`
struct without requiring an instance.

```{.rust .cb-nb session=a}
fn cry_to_sleep<T: Animal>() {
  T::cry();
  T::cry();
  T::sleep();
}
```

Now we can exercise it. You might think we'd do `call_me_sleepy<Cat>()` but rust
instead uses `cry_to_sleep::<Cat>()`. They call the `::<Type>` a turbo fish.
I don't know why. Does it `::<>` look like a fish?

```{.rust .cb-nb session=a}
cry_to_sleep::<Cat>();
```

```{.rust .cb-nb session=a}
cry_to_sleep::<Bird>();
```

I actually think this is pretty cool. It was only recently that [C# got
interface static
methods](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members),
and you can use them to do all kinds of cool things like make generics work
seamlessly with math operators in C#.

### Digression: Factories. Factories everywhere.

Remember how everyone needed a factory class in addition to their class? Why did
they need a factory? Well, because `new` is not dynamically dispatched. `new` only
operates on a concrete class. One could have added a static method to their
class like this:

```c#
class Gorilla {
  public static Gorilla New() { ... }
}
```

But one could not substitute a Gorilla class with some other Gorilla class.
There's only one Gorilla class.

#### A New Way

With static polymorphism you could instead write this:

```{.rust .cb-nb session=h}
trait Factory<T> {
  fn new() -> T;
}

struct Gorilla {
  is_mock: bool
}

impl Factory<Gorilla> for Gorilla {
  fn new() -> Gorilla {
    println!("Made a gorilla");
    Gorilla { is_mock: false }
  }
}

fn gorilla_keeper<F: Factory<Gorilla>>() {
  let gorilla = F::new();
  let gorilla = F::new();
}

gorilla_keeper::<Gorilla>();
```

Then if you needed to pass an object that was configured differently or perhaps
a mock object, you could do that.


```{.rust .cb-nb session=h}
struct MockGorilla {}

impl Factory<Gorilla> for MockGorilla {
  fn new() -> Gorilla {
    println!("Made a mock gorilla");
    Gorilla { is_mock: true }
  }
}

gorilla_keeper::<MockGorilla>();
```


This static polymorphism though is limited in the sense that the type must be
known at compile time. Each type requires the compiler to generate a new
function, which can cause [code
bloat](https://dirtyhandscoding.github.io/posts/on-cpp-code-bloat.html). It's
also not as flexible as dynamic polymorphism which can call types that were not
even present at compile time.

# Take Two

What we'd like instead is to call these functions on an instance of an object.
To do that in rust, we add the `&self` parameter.

```{.rust .cb-nb session=c}
trait Animal {
  fn cry(&self);
  fn sleep(&self);
  fn roam(&self);
}

struct Cat {}

impl Animal for Cat {
  fn cry(&self) {
    println!("meow");
  }
  fn sleep(&self) {
    println!("Zzzz");
  }
  fn roam(&self) {
    println!("patter patter pounce");
  }
}
```

Now let's try and run it.

```{.rust .cb-nb session=c}
let cat = Cat {};
cat.cry();
```

All right. It does what we expect. It does not offer any subclass polymorphism.
There's no means to inherit `Cat`'s behavior. But we can achieve another kind of
polymorphsim.

## Static Interface Polymorphism

We can write our `cry_to_sleep()` function for `Animal`, which is a kind of
interface polymorphism. It will work with any implementer of `Animal`. 

```{.rust .cb-nb session=c}
fn cry_to_sleep<T: Animal>(animal: T) {
  animal.cry();
  animal.cry();
  animal.sleep();
}
```

```{.rust .cb-nb session=c}
let cat = Cat {};
cry_to_sleep(cat);
```

However, this is not dynamic. The types are required to be known at compile
time. But there is no virtual function lookup required.


## Dynamic Interface Polymorphism

We can write a `cry_to_sleep()` variant that offers dynamic interface
polymorphism like this:

```{.rust .cb-nb session=c}
fn cry_to_sleep_dynamic(animal: &dyn Animal) {
  animal.cry();
  animal.cry();
  animal.sleep();
}
```

The function `cry_to_sleep_dynamic()` does not use generics. It does require a
virtual function table and lookup, but what's interesting is who decides a look
up will happen. The struct `Cat` does not determine whether its method calls
will use dynamic dispatch when its defined as is the case with many other
object oriented languages. There's no `virtual fn cry(&self)` in rust.

```{.rust .cb-nb session=c}
let cat = Cat {};
cry_to_sleep_dynamic(&cat);
```

Instead its the caller who determines whether a trait will use dynamic dispatch
by using the `dyn` keyword. We'll say more about the mechanism for it later.

# Take Three

If we want subtype polymorphism, we're going to have to implement it ourselves.
Our trait probably needs to know the base type. We can make our trait `Animal`
generic with respect to a `Base` type that is some other kind of `Animal` like
so:

```rust
trait Animal {
  type Base : Animal;
  fn cry(&self);
  // ...
}
```

And we can also define default implementations of trait functions. That
seems like a good place to put our dynamic dispatcher functionality call,
doesn't it? But we need to be able to get an instance of the base "class" or
struct.

```{.rust .cb-nb session=d}
trait Animal {
  type Base : Animal;
  fn base(&self) -> &Self::Base;
  fn cry(&self) {
    self.base().cry();
  }
  fn sleep(&self) {
    self.base().sleep();
  }
  fn roam(&self) {
    self.base().roam();
  }
}
```

Now we can implement only part of `Animal` for `Cat`.

```{.rust .cb-nb session=d}
struct Cat {}

impl Animal for Cat {
  type Base = Cat;
  fn base(&self) -> &Cat {
    &Cat {}
  }
  fn cry(&self) {
    println!("meow");
  }
}
```

If we call `cry()`, it works.

```{.rust .cb-nb session=d}
let cat = Cat {};
cat.cry();
```

But calling the unimplemented `roam()` will induce an infinite loop and cause a
stack overflow. (It's actually nice that it overflows fast instead of hanging
forever).

```{.rust .cb-nb session=d}
let cat = Cat {};
cat.roam();
```

The reason that happens is because we infinitely recurse down the base type. We
call `self.base().base().base()...` when there's no default implementation. We
can define a base type that implements all the functions to prevent infinite
recursion.

## Base Animal type

```{.rust .cb-run session=f}
trait Animal {
  type Base : Animal;
  fn base(&self) -> &Self::Base;
  fn cry(&self) {
    self.base().cry();
  }
  fn sleep(&self) {
    self.base().sleep();
  }
  fn roam(&self) {
    self.base().roam();
  }
}
```

```{.rust .cb-nb session=f}
struct BaseAnimal {}

impl Animal for BaseAnimal {
  type Base = BaseAnimal;
  fn base(&self) -> &BaseAnimal {
    panic!("Never call me here.");
  }
  fn cry(&self) { 
    println!("base cry");
  }
  fn sleep(&self) { 
    println!("base sleep");
  }
  fn roam(&self) { 
    println!("base roam");
  }
}
```

```{.rust .cb-nb session=f}
struct Cat {}

impl Animal for Cat {
  type Base = BaseAnimal;
  fn base(&self) -> &BaseAnimal {
    &BaseAnimal {}
  }
  fn cry(&self) {
    println!("meow");
  }
}
```

Now we can call `roam()` and we won't get an infinite loop at least.

```{.rust .cb-nb session=f}
let cat = Cat {};
cat.roam();
```

# Take Four

Instead of requiring a base struct for every object oriented trait, we could
change our `base()` signature to use an `Option<>`.

```rust
trait Animal {
  type Base : Animal;
  fn base(&self) -> Option<&Self::Base> {
    None
  }
  fn cry(&self) {
    if let Some(b) = self.base() {
      b.cry();
    } else {
      todo!("Not yet implemented");
    }
  }
  // ...
}
```

One further issue is what happens when a trait is extended? This happens all the
time with object oriented code. A subclass adds fields and new public methods.
Adding fields is easy in this setup:

```rust
Bat {
  speed: f32
}
```

Adding public "methods" that also do subtype polymorphism is less clear.

```{.rust .cb-nb session=f hide=all}
trait EndangeredAnimal : Animal {
  type Base : EndangeredAnimal;
  fn base(&self) -> Option<&<Self as EndangeredAnimal>::Base> {
    None
  }
  fn is_endangered(&self) -> bool {
    if let Some(b) = self.base() {
      b.is_endangered();
    } else {
      todo!("Not yet implemented");
    }

  }
}
```

```rust
trait EndangeredAnimal : Animal {
  fn is_endangered(&self) -> bool;
}
```

I'm going to leave this as an exercise for the reader partly because I think
it's going to be a mess, but it is doable.

# Ok, but how do crustaceans actually do this?

Let's go back to our second version of this trait.

```{.rust .cb-nb session=g}
trait Animal {
  fn cry(&self);
  fn sleep(&self);
  fn roam(&self);
}
```

```{.rust .cb-nb session=g}
struct Cat {} 

impl Animal for Cat {
  fn cry(&self) {
    println!("meow");
  }
  fn sleep(&self) {
    println!("Zzzz");
  }
  fn roam(&self) {
    println!("patter patter pounce");
  }
}

struct Bird {} 

impl Animal for Bird {
  fn cry(&self) {
    println!("chirp");
  }
  fn sleep(&self) {
    println!("Zzzz");
  }
  fn roam(&self) {
    println!("flit flit flurp");
  }
}
```

We've got two struct and we can use generics to call whichever implementation is present.

```{.rust .cb-nb session=g}
fn cry_to_sleep<T: Animal>(animal: T) {
  animal.cry();
  animal.cry();
  animal.sleep();
}
```

```{.rust .cb-nb session=g}
let cat = Cat {};
cry_to_sleep(cat);
```

## But what if I don't know the type exactly?

Suppose you have a heterogenous list of `Animal`s and you don't know their exact
type any more. How do you deal with that? You can't use the generic solution.

Ok, here's the really cool thing that rust does.

```{.rust .cb-nb session=g}
fn cry_to_sleep_dynamic(animal: &dyn Animal) {
  animal.cry();
  animal.cry();
  animal.sleep();
}
```

Rather than having a structural cost baked into every object that is capable of
polymorphism with a virtual function look up, rust has virtual function look up
on demand via its `dyn` keyword. When you use `dyn` you're passing and receiving
a "fat" pointer, which is two pointers: one to the regular struct, and another
to a virtual function look up table.

So you can call this method on bird

```{.rust .cb-nb session=g}
let bird = Bird {};
cry_to_sleep_dynamic(&bird);
```

or on cat.

```{.rust .cb-nb session=g}
let cat = Cat {};
cry_to_sleep_dynamic(&cat);
```

So you can have polymorphism in rust whenever you like, but the funny thing is
if you have a choice between direct static dispatch or an indirect dynamic
dispatch, one often prefers static dispatch.

![RUST NEWBIE: So when would I choose dynamic dispatch? CRUSTACEAN: That's the
 neat part. You don't.](rust-oo-the-neat-part.jpg)

Static dispatch is known at compile time. It's faster. It's simpler to reason
about. Use it if you can. I have found though that when dynamic dispatch is
available on a per call instead of a per object basis, it's amazing how little I
actually need it. But dynamic dispatch is there for whatever trait you need it
on, and you don't have to rely on the original author knowing which methods
needed to be marked "virtual".
